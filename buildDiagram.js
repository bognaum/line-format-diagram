import * as lib from "./lib.js";
import JsonEHl  from "./json-err-hl/json-err-hl.js";

export default function buildDiagram(self, elem, tOb) {
	elem.classList.add(self.clPref);
	const opts = Object.assign({
		style:  "",
		bdColor: "",
		lineNum: 0,
	}, elem.dataset);

	opts.bdColor = opts.bdColor &&= ` border-color: ${opts.bdColor}; `;

	const {tLevels, bLevels} = _getLevels(tOb);
	const htmlStr = _getHtmlStr(tOb, opts, tLevels, bLevels, self.clPref) 
		+ _getLinersHtmlStr(bLevels, self.clPref);

	elem.innerHTML = htmlStr;
}

function _getLevels(tOb) {
	const 
		tLevels = [],
		bLevels = [];

	recursive(tOb, 0);
	if (bLevels.length)
		bLevels.push(1);
	return {tLevels, bLevels};

	function recursive(tOb, level=0) {
		tLevels[level] ||= 0;

		if (tOb instanceof Array) {

			for (let node of tOb) 
				recursive(node, level);

		} else if (tOb.ch) {

			const node = tOb;

			if ("td" in node) {
				const 
					lines = node.td.split("\n"),
					n = lines.length;
				if (tLevels[level] < n)
					tLevels[level] = n;
				node.topDescr = lines.join("<br/>");
			} else {
				delete node.topDescr;
			}

			if (node.ch)
				if (typeof node.ch != "string")
					recursive(node.ch, level + 1);

			if (node.bd) {
				if (typeof node.ch == "string") {
					const 
						lines = node.bd.split("\n"),
						n = lines.length;
					bLevels.push(n);
					node.bottomDescr = lines.join("<br/>");
				} else {
					node.bottomDescr = null;
					node.errors = node.errors || [];
					node.errors.push("'node.bd' is deleted.");
				}
			} else {
				delete node.bottomDescr;
			}
		}
	}
}

function _getHtmlStr(templ, opts, tLevels, _bLevels, clPref) {
	let 
		bLevels = _bLevels.map(v => v),
		str     = "",
		serialN = -1;

	recursive(templ, 0);
	return str;

	function recursive(templ, level=0, inheritStyle="", partChIndex=0) {
		if (templ instanceof Array) {
			for (let [index, node] of templ.entries()) 
				recursive(node, level, inheritStyle, index);
		} else if (templ.ch) {

			const node = Object.assign({
				tbStyle: "",
				tdStyle: "",
				style  : "",
				bbStyle: "",
				bdStyle: "",
				class  : "",
			}, templ);

			const hFZ = _getHFZ(tLevels[level]);

			let 
				localBdColor = "border-color: transparent;",
				showBdsClass = "";

			if ("topDescr" in node) {
				showBdsClass = "show-borders";
				localBdColor = opts.bdColor;
			} else {}

			str += `<div class="${clPref}-part ${showBdsClass} ${node.class}" ` + 
				`style="${localBdColor}" ` +
				`data-serial-n="${++ serialN}"` +
				`data-part-ch-index="${partChIndex}">`;
			
			if ("topDescr" in node)
				str += [
					`<div `,
						`class="`,
							`${clPref}-top-descr `,
							`${clPref}-description `,
							`${clPref}-grid-v-liner `,
							`${node.class}`,
						`" `,
						`style="`,
							`\n/* Autogenerated*/  ${hFZ}`,
							`\n/*Common bdColor*/  ${opts.bdColor}`,
						`"`,
					`>`,

						`<div `,
							`class="${clPref}-h-line ${node.class}" `,
							`style="`,
								`\n/*Common bdColor*/  ${opts.bdColor} `,
								`\n/* Local tbStyle*/  ${node.tbStyle}"`,
						`></div>`,

						`<div `,
							`class="${clPref}-td-block ${node.class}" `,
							`style="/*Local tdStyle*/  ${node.tdStyle}"`,
						`>`,
								`${node.topDescr}`,
						`</div>`,

						`<div `,
							`class="${clPref}-h-line ${node.class}" `,
							`style="`,
								`\n/*Common bdColor*/  ${opts.bdColor} `,
								`\n/* Local tbStyle*/  ${node.tbStyle}"`,
						`></div>`,

					`</div>`,
				].join("");
			else 
				str += `<div 
					class="${clPref}-grid-v-liner" 
					style="/*Autogenerated*/  ${hFZ}"
				></div>`;

			if (node.ch)
				if (typeof node.ch == "string") {

					for (let i = level + 1; i < tLevels.length; i++) {
						let hFZ = _getHFZ(tLevels[i]);
						str += `<div class="${clPref}-grid-v-liner" style="${hFZ}"></div>`; 
					}

					str += [
						`<div `,
							`class="${clPref}-line-text ${node.class}" `,
							`style="`,
								`\n/*  Autogenerated*/  ${localBdColor}`,
								`\n/*   Common style*/  ${opts.style}`,
								`\n/*Inherited style*/  ${inheritStyle}`,
								`\n/*      Own style*/  ${node.style}`,
							`"`,
						`>${node.ch}</div>`
					].join("");

				} else if (typeof node.ch == "object" && "length" in node.ch) {
					recursive(node.ch, level + 1, inheritStyle+node.style);
				} else {
					throw new Error(`(!) "ch" must be a string or an array.`);
				}

			if (node.bottomDescr) {

				let strCount = bLevels.shift();
				str += [
					`<div class="${clPref}-bottom-rel-wr ${node.class}" `,
						`style="/*Common bdColor*/  ${opts.bdColor}">`,

						`<div class="${clPref}-bottom-rel ${node.class}" `,
							`style="`,
								`\n/*Common bdColor*/  ${opts.bdColor}`,
								`\n/* Local bbStyle*/  ${(node.bbStyle)}`,
							`">`,

							`<div class="${clPref}-rel-line ${node.class}" `,
								`style="`,
									`\n/*Common bdColor*/  ${opts.bdColor}`,
									`\n/* Local bbStyle*/  ${(node.bbStyle)}`,
								`">`
				].join("");

				bLevels.forEach((node) => {
					str += [
						`<div class="${clPref}-grid-bv-liner" `,
							`style="/*Autogenerated*/  height: ${node * 1.2}em"></div>`
					].join("");
				});

				str += [
								`<div `,
									`class="`,
										`${clPref}-bottom-descr `,
										`${clPref}-description `,
										`${clPref}-grid-bv-liner `,
										`${node.class}`,
									`" `,
									`style="`,
										`\n/*Autogenerated*/  height: ${strCount * 1.2}em; `,
										`\n/*Common bdColor*/  ${opts.bdColor}`,
										`\n/* Local bdStyle*/  ${(node.bdStyle)}`,
									`"`,
								`>`,
									`${node.bottomDescr}`,
								`</div>`,
							`</div>`,
						`</div>`,
					`</div>`,
				].join("");
			}

			

			str += `</div>`; // .${clPref}-part
		}
	}
}
function _getLinersHtmlStr(bLevels, clPref) {
	let str = "";
	for (let i = bLevels.length - 1; 0 <= i; i --) 
		str += `<div class="${clPref}-grid-bv-liner" `+
			`style="/*Autogenerated*/  height: ${bLevels[i] * 1.3}em"></div>`;
	
	return str;
}

function _getHFZ(lineCount) {
	return `height: ${lineCount * 1.5}em; font-size: 1em; `;
}